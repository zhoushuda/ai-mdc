---
enabled: true
name: dubbo-proxy-layer-rules
description: dubbo项目 Proxy 层开发规范,主要针对dubbo项目
---
## Proxy 层定位与基本职责

Proxy 层是 Dubbo 项目中服务对外暴露的实现层，典型特征和职责包括：

- 仅做“接口实现”与“上下层解耦”，不承载具体业务流程与数据访问细节；
- `implements` 对应 API 接口，只暴露被 Dubbo 服务暴露的公共方法；
- 所有方法参数与返回值均使用通用的 `DataTransferObject<T>`；
- 主要负责参数校验、调用底层 Service/Manager 组合服务、异常处理与日志输出；
- 严禁内部写复杂流程与可复用共性逻辑，具体逻辑应下沉到 Service。

---

## Proxy 层（对外 Dubbo 实现）开发规范

---

### 一、类级别规范

#### 1.1 注解与命名

- **类注解**：
  - 统一使用 `@Slf4j` + `@Service("order.xxxServiceProxy")`：
    - BeanName 建议以 `order.` 前缀开头，便于在 XML / 配置中引用。
- **命名规则**：
  - 所有对外 Dubbo 实现类统一以 `ServiceProxy` 结尾
  - 必须 `implements` 对应 `api` 包下的接口：
    - `public class TransportRuleServiceProxy implements TransportRuleService`

```java
@Slf4j
@Service("order.transportRuleServiceProxy")
public class TransportRuleServiceProxy implements TransportRuleService {
    // ...
}
```

#### 1.2 依赖注入方式

- **内部依赖**：
  - 注入 Manager / Service / 工具类推荐：

```java
@Autowired
private RedisOperations redisOperations;

@Resource(name = "order.transportRuleManager")
private TransportRuleManager transportRuleManager;
```

- **要求**：
  - 禁止在 Proxy 内部 `new` 出 Manager / Service / Mapper 对象。

---

### 二、职责边界

#### 2.1 Proxy 能做什么

- 作为 **Dubbo 对外实现层**，负责：
  - 接收 Dubbo 调用请求。
  - 入参基础校验（空值、格式基本判断）。
  - 调用内部 Service / Manager 执行业务。
  - 统一构建 `DataTransferObject<T>` 返回。
  - 打印关键日志（入参、出参核心信息）。

```java
@Override
public DataTransferObject<Integer> calculateFreight(FreightCalculateRequest request) {
    log.info("calculateFreight 入参:{}", JsonEntityTransform.Object2Json(request));
    DataTransferObject<Integer> dto = new DataTransferObject<>();
    if (Check.NuNCollection(request.getProductList())) {
        dto.setErrorMsg("参数无效");
        return dto;
    }
    Integer freight = normalCaculateFreight(request.getProductList(), request.getProvinceCode());
    dto.setData(freight);
    return dto;
}
```

#### 2.2 Proxy 不应该做什么

- 不直接写 SQL / 操作 Mapper（交给 Manager）。
- 不直接与 Redis / MQ 等基础设施频繁交互（优先通过 Manager / 专门组件）。
- 不在 Proxy 堆积大量业务计算逻辑：
  - 复杂运费规则、订单流程应拆到 Service / Manager 中。
- **不在 Proxy 层使用 `try-catch` 吞掉异常**：
  - 业务异常建议通过返回 `DataTransferObject` 的错误信息来体现；
  - 系统异常由统一异常处理机制（如 Dubbo 过滤器 / 全局切面）兜底。

---

### 三、入参与返回值规范

#### 3.1 入参

- **入参类型**：
  - 统一使用 `api` / `request` 包中定义的 Request / DTO：
    - `FreightCalculateRequest`
    - `TransportRuleRequest`
- **参数校验**：
  - 使用 `Check` 工具类统一做基础校验：

```java
if (Check.NuNObjs(request, request.getRuleSn())) {
    dto.setErrorMsg("参数无效");
    dto.setErrCode(DataTransferObject.ERROR);
    return dto;
}
```

#### 3.2 返回值

- **统一返回 `DataTransferObject<T>`**：
  - 成功：

```java
DataTransferObject<List<TransportCostVo>> dto = new DataTransferObject<>();
dto.setData(transportCostVo);
return dto;
```

  - 失败：

```java
dto.setErrorMsg("参数无效");
dto.setErrCode(DataTransferObject.ERROR);
return dto;
```

- 不直接返回实体或基本类型，除非是非常内部的私有方法。

---

### 四、异常与错误码规范（Proxy 层不写 try-catch）

#### 4.1 异常处理原则

- **Proxy 层不使用 `try-catch` 包裹整个业务方法**：
  - 业务可预期错误通过 `DataTransferObject` 的 `errorMsg` / `errCode` 表达；
  - 真正的系统异常（NPE、RPC 异常等）允许向上抛出，由统一异常处理机制兜底。
- 如确需在局部捕获异常（极少数场景）：
  - 只能用于资源释放或补充日志，**禁止吞掉异常**，应重新抛出或包装后抛出。

#### 4.2 错误码与文案

- 错误码：
  - 优先使用 `DataTransferObject.ERROR` 或业务枚举，不写裸数字。
- 错误文案：
  - 面向调用方（通常是其他服务或前端），应简短清晰：
    - `"参数无效"`、`"规则查询异常"` 等。
  - 对于需要区分处理的业务错误，使用专门业务枚举 + 描述。

---

### 五、日志规范

- 使用 `@Slf4j`，统一 `log.info / log.warn / log.error`。
- 日志内容至少包含：
  - 入参对象 JSON：`JsonEntityTransform.Object2Json(request)`
  - 关键业务标识：如 `ruleSn`、`productIds`、`provinceCode` 等。
- 异常日志由统一异常处理切面 / 过滤器记录，Proxy 层只需在关键路径打印业务日志。

```java
log.info("TransportRuleServiceProxy.calculateFreightV2 入参:{}", JsonEntityTransform.Object2Json(request));
```

---

### 六、推荐 Proxy 模板（无 try-catch）

```java
@Slf4j
@Service("order.demoServiceProxy")
public class DemoServiceProxy implements DemoService {

    @Resource(name = "order.demoManager")
    private DemoManager demoManager;

    @Override
    public DataTransferObject<DemoVO> demoMethod(DemoRequest request) {
        DataTransferObject<DemoVO> dto = new DataTransferObject<>();

        // 1. 基础校验
        if (Check.NuNObjs(request) || Check.NuNStrStrict(request.getBizCode())) {
            dto.setErrorMsg("参数无效");
            dto.setErrCode(DataTransferObject.ERROR);
            return dto;
        }

        // 2. 调用 Manager / Service（不在 Proxy 层 try-catch）
        DemoEntity entity = demoManager.findByBizCode(request.getBizCode());
        if (Check.NuNObj(entity)) {
            dto.setErrorMsg("数据不存在");
            return dto;
        }

        // 3. 组装返回
        DemoVO vo = DemoConverter.toVO(entity);
        dto.setData(vo);
        return dto;
    }
}
```

---

### 七、关键注意事项（Proxy 层）

1. 对外统一实现 `api` 接口，类名以 `ServiceProxy` 结尾。
2. 所有对外方法统一使用 `DataTransferObject<T>` 返回。
3. **Proxy 层不使用 `try-catch` 包裹整个方法**，异常由全局机制统一处理。
4. 复杂业务逻辑尽量下沉到 Service / Manager，保持 Proxy 简洁可读。
5. 日志必须包含入参 JSON 和关键标识，便于排查链路问题。

